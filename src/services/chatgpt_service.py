"""\nServi√ßo de integra√ß√£o com ChatGPT para gera√ß√£o de quest√µes\n"""\nimport os\nimport openai\nimport json\nimport re\nfrom typing import Dict, Any, Optional\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\nclass ChatGPTService:\n    """Servi√ßo para integra√ß√£o com ChatGPT"""\n    \n    def __init__(self):\n        self.client = openai.OpenAI(\n            api_key=os.getenv('OPENAI_API_KEY'),\n            base_url=os.getenv('OPENAI_API_BASE', 'https://api.openai.com/v1')\n        )\n        self.model = "gpt-4o-mini"  # Usar modelo dispon√≠vel\n        self.temperature = 0.7\n        self.max_tokens = 1500\n    \n    def _get_prompt_estatico(self) -> str:\n        """Retorna o prompt est√°tico para gera√ß√£o de quest√µes FGV"""\n        return """Voc√™ √© um elaborador de quest√µes da banca FGV. Seu papel √© criar uma √∫nica quest√£o objetiva, com base no edital do cargo abaixo. Siga as instru√ß√µes com rigor:\n\n- Formato da quest√£o: pode ser de m√∫ltipla escolha (com 5 alternativas, apenas uma correta), verdadeiro ou falso, completar lacuna, ou ordena√ß√£o l√≥gica.\n- A quest√£o deve ser in√©dita, clara, com linguagem t√©cnica adequada.\n- A alternativa correta deve ser coerente e as erradas plaus√≠veis, mas incorretas.\n- No final, inclua o gabarito e uma explica√ß√£o t√©cnica da resposta.\n- N√ÉO invente temas fora do edital. Utilize apenas o conte√∫do que est√° listado no edital fornecido.\n\nRetorne a resposta no seguinte formato JSON:\n{\n  \"questao\": \"texto da quest√£o\",\n  \"tipo\": \"multipla_escolha|verdadeiro_falso|completar_lacuna|ordenacao\",\n  \"alternativas\": [\"A) ...\", \"B) ...\", \"C) ...\", \"D) ...\", \"E) ...\"],\n  \"gabarito\": \"A\",\n  \"explicacao\": \"explica√ß√£o detalhada da resposta correta\",\n  \"tema\": \"tema principal da quest√£o\",\n  \"dificuldade\": \"facil|medio|dificil\"\n}"""\n    \n    def _get_prompt_dinamico(self, cargo: str, conteudo_edital: str, tipo_questao: str = "m√∫ltipla escolha") -> str:\n        """Gera o prompt din√¢mico baseado no perfil do usu√°rio"""\n        return f"""\nCargo do aluno: {cargo}\nConte√∫do do edital a ser cobrado: {conteudo_edital}\nTipo de quest√£o desejada: {tipo_questao}\n"""\n    \n    def gerar_questao(self, cargo: str, conteudo_edital: str, tipo_questao: str = "m√∫ltipla escolha") -> Optional[Dict[str, Any]]:\n        """\n        Gera uma quest√£o personalizada usando ChatGPT\n        \n        Args:\n            cargo: Cargo pretendido pelo usu√°rio\n            conteudo_edital: Conte√∫do espec√≠fico do edital\n            tipo_questao: Tipo de quest√£o desejada\n            \n        Returns:\n            Dict com a quest√£o gerada ou None em caso de erro\n        """\n        try:\n            # Verificar se a API key est√° configurada\n            if not os.getenv('OPENAI_API_KEY'):\n                print("‚ö†Ô∏è OPENAI_API_KEY n√£o configurada, usando fallback")\n                return self._gerar_questao_fallback(cargo, conteudo_edital)\n            \n            # Combinar prompts est√°tico e din√¢mico\n            prompt_completo = self._get_prompt_estatico() + self._get_prompt_dinamico(cargo, conteudo_edital, tipo_questao)\n            \n            # Fazer chamada para ChatGPT\n            response = self.client.chat.completions.create(\n                model=self.model,\n                messages=[\n                    {"role": "system", "content": "Voc√™ √© um especialista em elabora√ß√£o de quest√µes para concursos p√∫blicos da banca FGV."},\n                    {"role": "user", "content": prompt_completo}\n                ],\n                temperature=self.temperature,\n                max_tokens=self.max_tokens\n            )\n            \n            # Extrair resposta\n            resposta = response.choices[0].message.content.strip()\n            \n            # Tentar extrair JSON da resposta\n            questao_data = self._extrair_json_resposta(resposta)\n            \n            if questao_data:\n                # Adicionar metadados\n                questao_data['cargo'] = cargo\n                questao_data['conteudo_edital'] = conteudo_edital\n                questao_data['prompt_usado'] = prompt_completo[:200] + "..."\n                \n                return questao_data\n            else:\n                print(f"‚ùå Erro ao extrair JSON da resposta: {resposta[:200]}...")\n                return self._gerar_questao_fallback(cargo, conteudo_edital)\n                \n        except Exception as e:\n            print(f"‚ùå Erro ao gerar quest√£o: {e}")\n            return self._gerar_questao_fallback(cargo, conteudo_edital)\n    \n    def _gerar_questao_fallback(self, cargo: str, conteudo_edital: str) -> Dict[str, Any]:\n        """Gera uma quest√£o de fallback quando a API falha"""\n        return {\n            "questao": f"Quest√£o sobre {conteudo_edital} para o cargo de {cargo}",\n            "tipo": "multipla_escolha",\n            "alternativas": [\n                {"id": "A", "texto": "Alternativa A"},\n                {"id": "B", "texto": "Alternativa B"},\n                {"id": "C", "texto": "Alternativa C"},\n                {"id": "D", "texto": "Alternativa D"},\n                {"id": "E", "texto": "Alternativa E"}\n            ],\n            "gabarito": "C",\n            "explicacao": "Explica√ß√£o da resposta correta",\n            "tema": conteudo_edital,\n            "dificuldade": "medio"\n        }\n    \n    def _extrair_json_resposta(self, resposta: str) -> Optional[Dict[str, Any]]:\n        """Extrai JSON da resposta do ChatGPT"""\n        try:\n            # Tentar encontrar JSON na resposta\n            json_match = re.search(r'\\{.*\\}', resposta, re.DOTALL)\n            if json_match:\n                json_str = json_match.group()\n                return json.loads(json_str)\n            \n            # Se n√£o encontrar JSON, tentar parsear a resposta inteira\n            return json.loads(resposta)\n            \n        except json.JSONDecodeError:\n            # Se falhar, tentar extrair manualmente\n            return self._extrair_manual_resposta(resposta)\n    \n    def _extrair_manual_resposta(self, resposta: str) -> Optional[Dict[str, Any]]:\n        """Extrai dados manualmente se JSON falhar"""\n        try:\n            # Implementar extra√ß√£o manual b√°sica\n            questao_data = {\n                "questao": "",\n                "tipo": "multipla_escolha",\n                "alternativas": [],\n                "gabarito": "",\n                "explicacao": "",\n                "tema": "",\n                "dificuldade": "medio"\n            }\n            \n            # Extrair quest√£o (primeira linha ou par√°grafo)\n            linhas = resposta.split('\\n')\n            for linha in linhas:\n                if linha.strip() and not linha.startswith(('A)', 'B)', 'C)', 'D)', 'E)')):\n                    questao_data["questao"] = linha.strip()\n                    break\n            \n            # Extrair alternativas\n            alternativas = []\n            for linha in linhas:\n                if re.match(r'^[A-E]\\)', linha.strip()):\n                    alternativas.append(linha.strip())\n            \n            questao_data["alternativas"] = alternativas\n            \n            # Extrair gabarito (procurar por "Gabarito:" ou similar)\n            for linha in linhas:\n                if "gabarito" in linha.lower() or "resposta" in linha.lower():\n                    match = re.search(r'[A-E]', linha)\n                    if match:\n                        questao_data["gabarito"] = match.group()\n                        break\n            \n            # Extrair explica√ß√£o\n            explicacao_iniciou = False\n            explicacao_linhas = []\n            for linha in linhas:\n                if "explica√ß√£o" in linha.lower() or "justificativa" in linha.lower():\n                    explicacao_iniciou = True\n                    continue\n                if explicacao_iniciou and linha.strip():\n                    explicacao_linhas.append(linha.strip())\n            \n            questao_data["explicacao"] = " ".join(explicacao_linhas)\n            \n            return questao_data if questao_data["questao"] else None\n            \n        except Exception as e:\n            print(f"‚ùå Erro na extra√ß√£o manual: {e}")\n            return None\n    \n    def validar_questao(self, questao_data: Dict[str, Any]) -> bool:\n        """Valida se a quest√£o gerada est√° completa"""\n        campos_obrigatorios = ["questao", "alternativas", "gabarito", "explicacao"]\n        \n        for campo in campos_obrigatorios:\n            if not questao_data.get(campo):\n                return False\n        \n        # Validar alternativas (deve ter pelo menos 2)\n        if len(questao_data.get("alternativas", [])) < 2:\n            return False\n        \n        # Validar gabarito\n        gabarito = questao_data.get("gabarito", "")\n        if not gabarito or gabarito not in "ABCDE":\n            return False\n        \n        return True\n    \n    def gerar_explicacao(self, prompt_explicacao: str) -> Optional[str]:\n        """Gera explica√ß√£o detalhada usando o ChatGPT"""\n        try:\n            # Verificar se a API key est√° configurada\n            if not os.getenv('OPENAI_API_KEY'):\n                print("‚ö†Ô∏è OPENAI_API_KEY n√£o configurada, usando explica√ß√£o fallback")\n                return "Explica√ß√£o detalhada n√£o dispon√≠vel. Configure a API key do OpenAI para obter explica√ß√µes personalizadas."\n            \n            print("ü§ñ Enviando prompt para gerar explica√ß√£o...")\n            \n            response = self.client.chat.completions.create(\n                model=self.model,\n                messages=[\n                    {\n                        "role": "system",\n                        "content": "Voc√™ √© um professor especialista em concursos p√∫blicos. Forne√ßa explica√ß√µes claras, did√°ticas e fundamentadas em legisla√ß√£o quando aplic√°vel."\n                    },\n                    {\n                        "role": "user",\n                        "content": prompt_explicacao\n                    }\n                ],\n                temperature=0.3,  # Menor temperatura para respostas mais precisas\n                max_tokens=800\n            )\n            \n            explicacao = response.choices[0].message.content.strip()\n            print(f"‚úÖ Explica√ß√£o gerada: {explicacao[:100]}...")\n            return explicacao\n            \n        except Exception as e:\n            print(f"‚ùå Erro ao gerar explica√ß√£o: {e}")\n            return "N√£o foi poss√≠vel gerar uma explica√ß√£o detalhada no momento. Tente novamente mais tarde."\n\n# Inst√¢ncia global do servi√ßo\nchatgpt_service = ChatGPTService()\n